"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { Geometry, Mesh, Program, Renderer, Texture } from "ogl";

type Particle = {
  x: number;
  y: number;
  z: number;
  vx: number;
  vy: number;
  vz: number;
  ax: number;
  ay: number;
  az: number;
  rotX: number;
  rotZ: number;
  projX: number;
  projY: number;
  radiusCurrent: number;
  framesAlive: number;
  angle: number;
  force: number;
  alpha: number;
  growDuration: number;
  waitDuration: number;
  shrinkDuration: number;
  isDead: boolean;
  glyphIndex: number;
  glyphRotation: number;
};

/**
 * Proof-of-concept MSDF glyph particle sphere.
 *
 * Key goals:
 * - Keep the existing particle motion model (sphere surface spawn, rotation, drift, fade lifecycle).
 * - Replace the 2D canvas dot render with GPU-rendered MSDF glyph quads for crisp, vector-like glyph edges.
 * - Use a curated glyph set (target 256) so glyphs are readable and spacing is adequate.
 *
 * Required assets (generated by a separate build step):
 * - public/msdf/glyph-atlas.png
 * - public/msdf/glyph-atlas.json
 *
 * JSON format expectations (loosely BMFont-compatible):
 * - common.scaleW / common.scaleH: atlas width/height in pixels
 * - chars: array of entries with at least { id, x, y, width, height }
 *   where `id` is the unicode codepoint.
 * - distanceField.distanceRange (optional): MSDF pixel range (commonly 2-8)
 */

const CONFIG = {
  sphereRadius: 290,
  framesToRotate: 800,
  perspective: 797,
  // Reduced for readability: fewer, larger glyphs.
  newParticlesPerFrame: 3,
  // Reduced cap for readability: avoids overcrowding.
  maxParticles: 240,
  growDuration: 83,
  waitDuration: 10,
  shrinkDuration: 456,
  // Matches existing AboutParticleSphere tint.
  color: [0x06, 0xcf, 0xbb] as const,
  maxAcceleration: { x: 0.028, y: 0.028, z: 0.028 },
  startVelocity: { x: 0.0007, y: 0.0007, z: 0.0007 },

  // Screen-space glyph sizing. We clamp so glyphs remain readable.
  glyphSizePx: { min: 8, max: 18 },

  // Optional per-particle glyph rotation in radians.
  // Keep small for legibility; you can increase later if desired.
  glyphRotationRange: 0.35,
};

const VELOCITY_DAMPING = 0.965;
const MAX_RADIUS_MULTIPLIER = 1.08;

/**
 * Curated glyph set (target 256).
 *
 * Notes:
 * - We intentionally exclude the symbol set you listed (punctuation-heavy and math operators).
 * - We keep the Mosaic-used CJK subset for now (Katakana + Hangul subset as seen in the mosaic atlas).
 * - Arabic is included from the mosaic list.
 * - Target is 256 for a single atlas page (e.g. 16x16), but the atlas can be non-grid; we rely on JSON metrics.
 * - TODO: Revisit this list based on visual appearance and font coverage.
 */
const GLYPHS: string[] = (() => {
  const latinUpper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
  const latinLower = "abcdefghijklmnopqrstuvwxyz".split("");
  const digits = "0123456789".split("");

  // Limited Latin-1 supplement letters (no punctuation).
  const latinExtended = [
    "À",
    "Á",
    "Â",
    "Ã",
    "Ä",
    "Å",
    "Æ",
    "Ç",
    "È",
    "É",
    "Ê",
    "Ë",
    "Ì",
    "Í",
    "Î",
    "Ï",
    "Ð",
    "Ñ",
    "Ò",
    "Ó",
    "Ô",
    "Õ",
    "Ö",
    "Ø",
    "Ù",
    "Ú",
    "Û",
    "Ü",
    "Ý",
    "Þ",
    "ß",
    "ö",
  ];

  // Mosaic-used Katakana subset.
  const katakana = ["ア", "ウ", "カ", "ラ"];

  // Mosaic-used Hangul subset.
  const hangul = ["가", "나", "다", "라", "마", "바", "사", "아", "자", "차", "카", "타", "파", "하"];

  // Arabic subset as used in the mosaic list.
  const arabic = [
    "ا",
    "ب",
    "ت",
    "ث",
    "ج",
    "ح",
    "خ",
    "د",
    "ذ",
    "ر",
    "ز",
    "س",
    "ش",
    "ص",
    "ض",
    "ط",
    "ظ",
    "ع",
    "غ",
    "ف",
    "ق",
    "ك",
    "ل",
    "م",
    "ن",
    "ه",
    "و",
    "ي",
  ];

  // Small Greek subset (letters only) for variety.
  const greek = [
    "α",
    "β",
    "γ",
    "δ",
    "ε",
    "ζ",
    "η",
    "θ",
    "ι",
    "κ",
    "λ",
    "μ",
    "ν",
    "ξ",
    "ο",
    "π",
    "ρ",
    "σ",
    "τ",
    "υ",
    "φ",
    "χ",
    "ψ",
    "ω",
  ];

  // Simple filler letters to reach 256 while staying within letter-like glyphs.
  // TODO: Replace these with a more intentional set (additional CJK/Arabic variants, selected symbols, etc.).
  const filler = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");

  const all = [
    ...latinUpper,
    ...latinLower,
    ...digits,
    ...latinExtended,
    ...katakana,
    ...hangul,
    ...arabic,
    ...greek,
  ];

  const out: string[] = [];
  const seen = new Set<string>();

  for (const g of all) {
    if (!seen.has(g)) {
      seen.add(g);
      out.push(g);
    }
  }

  let i = 0;
  while (out.length < 256) {
    const g = filler[i % filler.length] ?? "A";
    // Duplicates are allowed for PoC padding, but keep distribution stable.
    out.push(g);
    i += 1;
  }

  return out.slice(0, 256);
})();

type MsdfAtlasJson = {
  common?: { scaleW?: number; scaleH?: number };
  chars?: Array<{ id?: number; x?: number; y?: number; width?: number; height?: number }>;
  distanceField?: { distanceRange?: number };
};

type GlyphUvRect = {
  u0: number;
  v0: number;
  u1: number;
  v1: number;
};

const clamp = (v: number, min: number, max: number) => Math.min(max, Math.max(min, v));

const median = (a: number, b: number, c: number) => Math.max(Math.min(a, b), Math.min(Math.max(a, b), c));

export function AboutParticleSphereMSDF({ className = "" }: { className?: string }) {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const [isReady, setIsReady] = useState(false);

  const glyphCodepoints = useMemo(() => GLYPHS.map((g) => g.codePointAt(0) ?? 0), []);

  useEffect(() => {
    const ctn = containerRef.current;
    if (!ctn) return;

    let raf = 0;
    let running = true;

    const renderer = new Renderer({ dpr: Math.min(window.devicePixelRatio || 1, 2), alpha: true });
    const { gl } = renderer;

    gl.canvas.style.position = "absolute";
    gl.canvas.style.inset = "0";
    gl.canvas.style.width = "100%";
    gl.canvas.style.height = "100%";
    gl.canvas.style.pointerEvents = "none";

    // Normal alpha blending for readable glyphs.
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    // Attach canvas.
    while (ctn.firstChild) ctn.removeChild(ctn.firstChild);
    ctn.appendChild(gl.canvas);

    // Load MSDF atlas assets.
    const loadAtlas = async () => {
      const [jsonRes, img] = await Promise.all([
        fetch("/msdf/glyph-atlas.json"),
        new Promise<HTMLImageElement>((resolve, reject) => {
          const image = new Image();
          image.onload = () => resolve(image);
          image.onerror = reject;
          image.src = "/msdf/glyph-atlas.png";
        }),
      ]);

      const atlasJson = (await jsonRes.json()) as MsdfAtlasJson;

      const scaleW = atlasJson.common?.scaleW ?? img.naturalWidth ?? img.width;
      const scaleH = atlasJson.common?.scaleH ?? img.naturalHeight ?? img.height;
      const distanceRange = atlasJson.distanceField?.distanceRange ?? 4;

      const chars = atlasJson.chars ?? [];
      const byId = new Map<number, { x: number; y: number; w: number; h: number }>();

      for (const c of chars) {
        const id = c.id ?? -1;
        const x = c.x ?? 0;
        const y = c.y ?? 0;
        const w = c.width ?? 0;
        const h = c.height ?? 0;
        if (id >= 0 && w > 0 && h > 0) {
          byId.set(id, { x, y, w, h });
        }
      }

      const uvRects: GlyphUvRect[] = glyphCodepoints.map((cp) => {
        const entry = byId.get(cp);
        if (!entry) {
          // Fallback to first glyph if the atlas does not contain the requested codepoint.
          const fallback = byId.get(glyphCodepoints[0] ?? 65);
          if (!fallback) {
            return { u0: 0, v0: 0, u1: 1, v1: 1 };
          }
          const u0 = fallback.x / scaleW;
          const u1 = (fallback.x + fallback.w) / scaleW;
          // Flip Y so 0,0 is bottom-left in UV space.
          const v1 = 1 - fallback.y / scaleH;
          const v0 = 1 - (fallback.y + fallback.h) / scaleH;
          return { u0, v0, u1, v1 };
        }

        const u0 = entry.x / scaleW;
        const u1 = (entry.x + entry.w) / scaleW;
        const v1 = 1 - entry.y / scaleH;
        const v0 = 1 - (entry.y + entry.h) / scaleH;
        return { u0, v0, u1, v1 };
      });

      const atlasTex = new Texture(gl, {
        image: img,
        generateMipmaps: false,
        minFilter: gl.LINEAR,
        magFilter: gl.LINEAR,
      });

      return { atlasTex, uvRects, distanceRange };
    };

    const vertex = `
attribute vec2 position;
attribute vec2 uv;

attribute vec2 aTranslate;
attribute float aScale;
attribute float aAlpha;
attribute float aGlyph;
attribute float aRot;
attribute vec4 aUvRect;

uniform vec2 uResolution;

varying vec2 vUv;
varying float vAlpha;
varying vec4 vUvRect;

vec2 rotate2d(vec2 p, float a) {
  float s = sin(a);
  float c = cos(a);
  return vec2(c * p.x - s * p.y, s * p.x + c * p.y);
}

void main() {
  // Local quad coordinates are [-1..1].
  vec2 local = rotate2d(position, aRot) * aScale;
  vec2 px = aTranslate + local;

  // Convert pixel coords -> clip space.
  vec2 clip = (px / uResolution) * 2.0 - 1.0;
  clip.y = -clip.y;

  gl_Position = vec4(clip, 0.0, 1.0);

  vUv = uv;
  vAlpha = aAlpha;
  vUvRect = aUvRect;
}
`;

    const fragment = `
precision highp float;

uniform sampler2D uAtlas;
uniform vec3 uColor;
uniform float uDistanceRange;

varying vec2 vUv;
varying float vAlpha;
varying vec4 vUvRect;

float median3(float r, float g, float b) {
  return max(min(r, g), min(max(r, g), b));
}

void main() {
  // Map quad UV into glyph rect.
  vec2 uv = mix(vUvRect.xy, vUvRect.zw, vUv);

  vec3 msdf = texture2D(uAtlas, uv).rgb;

  // Standard MSDF reconstruction.
  float sd = median3(msdf.r, msdf.g, msdf.b) - 0.5;

  // Convert distance to screen-space coverage.
  // fwidth gives us resolution-independent smoothing.
  float w = fwidth(sd);
  float alpha = clamp(sd / max(w, 1e-6) + 0.5, 0.0, 1.0);

  // Multiply by particle lifecycle alpha.
  alpha *= vAlpha;

  if (alpha <= 0.001) discard;

  gl_FragColor = vec4(uColor, alpha);
}
`;

    const init = async () => {
      const { atlasTex, uvRects, distanceRange } = await loadAtlas();
      if (!running) return;

      const maxParticles = CONFIG.maxParticles;

      const vertsPerParticle = 6;
      const totalVerts = maxParticles * vertsPerParticle;

      // Quad (two triangles) in local space.
      const basePositions = [-1, -1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1];
      const baseUvs = [0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1];

      const positions = new Float32Array(totalVerts * 2);
      const uvs = new Float32Array(totalVerts * 2);

      for (let i = 0; i < totalVerts; i++) {
        const b = (i % vertsPerParticle) * 2;
        positions[i * 2] = basePositions[b] ?? 0;
        positions[i * 2 + 1] = basePositions[b + 1] ?? 0;

        uvs[i * 2] = baseUvs[b] ?? 0;
        uvs[i * 2 + 1] = baseUvs[b + 1] ?? 0;
      }

      // Instanced attributes.
      const aTranslate = new Float32Array(totalVerts * 2);
      const aScale = new Float32Array(totalVerts);
      const aAlpha = new Float32Array(totalVerts);
      const aGlyph = new Float32Array(totalVerts);
      const aRot = new Float32Array(totalVerts);
      const aUvRect = new Float32Array(totalVerts * 4);

      const geometry = new Geometry(gl, {
        position: { size: 2, data: positions },
        uv: { size: 2, data: uvs },
        aTranslate: { size: 2, data: aTranslate },
        aScale: { size: 1, data: aScale },
        aAlpha: { size: 1, data: aAlpha },
        aGlyph: { size: 1, data: aGlyph },
        aRot: { size: 1, data: aRot },
        aUvRect: { size: 4, data: aUvRect },
      });

      const program = new Program(gl, {
        vertex,
        fragment,
        uniforms: {
          uAtlas: { value: atlasTex },
          uResolution: { value: [1, 1] },
          uColor: { value: [CONFIG.color[0] / 255, CONFIG.color[1] / 255, CONFIG.color[2] / 255] },
          // Included for future tuning; many MSDF shaders incorporate distanceRange.
          uDistanceRange: { value: distanceRange },
        },
        transparent: true,
        depthTest: false,
        depthWrite: false,
      });

      const mesh = new Mesh(gl, { geometry, program });

      // Motion model: same structure as the original 2D canvas version.
      const particles: Particle[] = [];
      let angle = 0;
      let width = 0;
      let height = 0;

      const randomRange = (min: number, max: number) => Math.random() * (max - min) + min;

      const pickGlyphIndex = () => Math.floor(Math.random() * GLYPHS.length);

      const initParticle = (p: Particle) => {
        p.angle = Math.random() * Math.PI * 2;
        p.force = Math.acos(randomRange(-1, 1));
        p.alpha = 0;
        p.isDead = false;
        p.framesAlive = 0;

        p.x = CONFIG.sphereRadius * Math.sin(p.force) * Math.cos(p.angle);
        p.y = CONFIG.sphereRadius * Math.sin(p.force) * Math.sin(p.angle);
        p.z = CONFIG.sphereRadius * Math.cos(p.force);

        p.vx = CONFIG.startVelocity.x * p.x;
        p.vy = CONFIG.startVelocity.y * p.y;
        p.vz = CONFIG.startVelocity.z * p.z;

        p.growDuration = CONFIG.growDuration + randomRange(-CONFIG.growDuration / 4, CONFIG.growDuration / 4);
        p.waitDuration = CONFIG.waitDuration + randomRange(-CONFIG.waitDuration / 4, CONFIG.waitDuration / 4);
        p.shrinkDuration = CONFIG.shrinkDuration + randomRange(-CONFIG.shrinkDuration / 4, CONFIG.shrinkDuration / 4);

        p.ax = 0;
        p.ay = 0;
        p.az = 0;

        p.glyphIndex = pickGlyphIndex();
        p.glyphRotation = randomRange(-CONFIG.glyphRotationRange, CONFIG.glyphRotationRange);
      };

      const createParticle = () => {
        const particle: Particle = {
          x: 0,
          y: 0,
          z: 0,
          vx: 0,
          vy: 0,
          vz: 0,
          ax: 0,
          ay: 0,
          az: 0,
          rotX: 0,
          rotZ: 0,
          projX: 0,
          projY: 0,
          radiusCurrent: 0,
          framesAlive: 0,
          angle: 0,
          force: 0,
          alpha: 0,
          growDuration: CONFIG.growDuration,
          waitDuration: CONFIG.waitDuration,
          shrinkDuration: CONFIG.shrinkDuration,
          isDead: false,
          glyphIndex: 0,
          glyphRotation: 0,
        };
        initParticle(particle);
        particles.push(particle);
      };

      const updateParticle = (p: Particle, cosAngle: number, sinAngle: number) => {
        if (p.framesAlive > p.growDuration + p.waitDuration) {
          p.vx = (p.vx + p.ax + CONFIG.maxAcceleration.x * (Math.random() * 2 - 1)) * VELOCITY_DAMPING;
          p.vy = (p.vy + p.ay + CONFIG.maxAcceleration.y * (Math.random() * 2 - 1)) * VELOCITY_DAMPING;
          p.vz = (p.vz + p.az + CONFIG.maxAcceleration.z * (Math.random() * 2 - 1)) * VELOCITY_DAMPING;
          p.x += p.vx;
          p.y += p.vy;
          p.z += p.vz;

          const radius = Math.sqrt(p.x * p.x + p.y * p.y + p.z * p.z);
          const maxRadius = CONFIG.sphereRadius * MAX_RADIUS_MULTIPLIER;
          if (radius > maxRadius) {
            const s = maxRadius / radius;
            p.x *= s;
            p.y *= s;
            p.z *= s;
          }
        }

        p.rotX = cosAngle * p.x + sinAngle * p.z;
        p.rotZ = -sinAngle * p.x + cosAngle * p.z;
        p.radiusCurrent = Math.max(0.01, CONFIG.perspective / (CONFIG.perspective - p.rotZ));

        p.projX = p.rotX * p.radiusCurrent + width / 2;
        p.projY = p.y * p.radiusCurrent + height / 2;

        p.framesAlive += 1;

        if (p.framesAlive < p.growDuration) {
          p.alpha = p.framesAlive / p.growDuration;
        } else if (p.framesAlive < p.growDuration + p.waitDuration) {
          p.alpha = 1;
        } else if (p.framesAlive < p.growDuration + p.waitDuration + p.shrinkDuration) {
          p.alpha =
            (p.growDuration + p.waitDuration + p.shrinkDuration - p.framesAlive) / p.shrinkDuration;
        } else {
          p.isDead = true;
        }

        p.alpha *= Math.min(0.92, Math.max(0.55, p.rotZ / CONFIG.sphereRadius));
        p.alpha = Math.min(1, Math.max(0, p.alpha));

        if (p.isDead) {
          initParticle(p);
        }
      };

      const resize = () => {
        const rect = ctn.getBoundingClientRect();
        width = Math.max(1, rect.width);
        height = Math.max(1, rect.height);

        renderer.setSize(width, height);
        program.uniforms.uResolution.value = [width, height];
      };

      const ro = new ResizeObserver(resize);
      ro.observe(ctn);
      resize();

      setIsReady(true);

      const step = () => {
        if (!running) return;

        angle = (angle + (2 * Math.PI) / CONFIG.framesToRotate) % (2 * Math.PI);
        const sinAngle = Math.sin(angle);
        const cosAngle = Math.cos(angle);

        for (let i = 0; i < CONFIG.newParticlesPerFrame; i++) {
          if (particles.length < CONFIG.maxParticles) {
            createParticle();
          }
        }

        particles.forEach((p) => updateParticle(p, cosAngle, sinAngle));

        // Write instance buffers.
        for (let i = 0; i < CONFIG.maxParticles; i++) {
          const p = particles[i];
          const baseVert = i * 6;

          if (!p) {
            for (let v = 0; v < 6; v++) {
              aAlpha[baseVert + v] = 0;
            }
            continue;
          }

          const sizePx = clamp(p.radiusCurrent * 8, CONFIG.glyphSizePx.min, CONFIG.glyphSizePx.max);
          const rect = uvRects[p.glyphIndex] ?? uvRects[0];

          for (let v = 0; v < 6; v++) {
            const vi = baseVert + v;
            const idx2 = vi * 2;
            const idx4 = vi * 4;

            aTranslate[idx2] = p.projX;
            aTranslate[idx2 + 1] = p.projY;

            aScale[vi] = sizePx;
            aAlpha[vi] = p.alpha;
            aGlyph[vi] = p.glyphIndex;
            aRot[vi] = p.glyphRotation;

            aUvRect[idx4] = rect?.u0 ?? 0;
            aUvRect[idx4 + 1] = rect?.v0 ?? 0;
            aUvRect[idx4 + 2] = rect?.u1 ?? 1;
            aUvRect[idx4 + 3] = rect?.v1 ?? 1;
          }
        }

        geometry.attributes.aTranslate.needsUpdate = true;
        geometry.attributes.aScale.needsUpdate = true;
        geometry.attributes.aAlpha.needsUpdate = true;
        geometry.attributes.aGlyph.needsUpdate = true;
        geometry.attributes.aRot.needsUpdate = true;
        geometry.attributes.aUvRect.needsUpdate = true;

        renderer.render({ scene: mesh });
        raf = window.requestAnimationFrame(step);
      };

      raf = window.requestAnimationFrame(step);

      return () => {
        ro.disconnect();
      };
    };

    let cleanup: (() => void) | undefined;

    init()
      .then((c) => {
        cleanup = c;
      })
      .catch((err) => {
        console.warn("AboutParticleSphereMSDF: failed to initialize", err);
      });

    return () => {
      running = false;
      if (raf) window.cancelAnimationFrame(raf);
      cleanup?.();

      try {
        gl.getExtension("WEBGL_lose_context")?.loseContext();
      } catch {
        // ignore
      }
    };
  }, [glyphCodepoints]);

  return (
    <div
      ref={containerRef}
      className={className}
      style={{
        width: "100%",
        height: "100%",
        position: "relative",
        overflow: "hidden",
        pointerEvents: "none",
      }}
      data-about-particle-sphere-msdf={isReady ? "ready" : "loading"}
    />
  );
}
